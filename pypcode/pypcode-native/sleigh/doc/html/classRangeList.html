<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: RangeList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classRangeList-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RangeList Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A disjoint set of Ranges, possibly across multiple address spaces.  
 <a href="classRangeList.html#details">More...</a></p>

<p><code>#include &lt;address.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8b5850c722bc4e7b612d87ca6a43fab"><td class="memItemLeft" align="right" valign="top"><a id="ae8b5850c722bc4e7b612d87ca6a43fab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#ae8b5850c722bc4e7b612d87ca6a43fab">RangeList</a> (const <a class="el" href="classRangeList.html">RangeList</a> &amp;op2)</td></tr>
<tr class="memdesc:ae8b5850c722bc4e7b612d87ca6a43fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ae8b5850c722bc4e7b612d87ca6a43fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2138ead753fe147949be8b725f1ee89b"><td class="memItemLeft" align="right" valign="top"><a id="a2138ead753fe147949be8b725f1ee89b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a2138ead753fe147949be8b725f1ee89b">RangeList</a> (void)</td></tr>
<tr class="memdesc:a2138ead753fe147949be8b725f1ee89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty container. <br /></td></tr>
<tr class="separator:a2138ead753fe147949be8b725f1ee89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab3e451530bb1f7c8c1bd66a7df32a5"><td class="memItemLeft" align="right" valign="top"><a id="afab3e451530bb1f7c8c1bd66a7df32a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#afab3e451530bb1f7c8c1bd66a7df32a5">clear</a> (void)</td></tr>
<tr class="memdesc:afab3e451530bb1f7c8c1bd66a7df32a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear <b>this</b> container to empty. <br /></td></tr>
<tr class="separator:afab3e451530bb1f7c8c1bd66a7df32a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78a4eba9787c374803f2503fdd38f3c"><td class="memItemLeft" align="right" valign="top"><a id="ad78a4eba9787c374803f2503fdd38f3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#ad78a4eba9787c374803f2503fdd38f3c">empty</a> (void) const</td></tr>
<tr class="memdesc:ad78a4eba9787c374803f2503fdd38f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> is empty. <br /></td></tr>
<tr class="separator:ad78a4eba9787c374803f2503fdd38f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890040e91f6bf573706b76a185ab6cbe"><td class="memItemLeft" align="right" valign="top"><a id="a890040e91f6bf573706b76a185ab6cbe"></a>
set&lt; <a class="el" href="classRange.html">Range</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a890040e91f6bf573706b76a185ab6cbe">begin</a> (void) const</td></tr>
<tr class="memdesc:a890040e91f6bf573706b76a185ab6cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to beginning <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a>. <br /></td></tr>
<tr class="separator:a890040e91f6bf573706b76a185ab6cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae742ac5298a0d263210366e7aa0bb0b"><td class="memItemLeft" align="right" valign="top"><a id="aae742ac5298a0d263210366e7aa0bb0b"></a>
set&lt; <a class="el" href="classRange.html">Range</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#aae742ac5298a0d263210366e7aa0bb0b">end</a> (void) const</td></tr>
<tr class="memdesc:aae742ac5298a0d263210366e7aa0bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to ending <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a>. <br /></td></tr>
<tr class="separator:aae742ac5298a0d263210366e7aa0bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05df36bbb7206ca0cfb8b5a74fb1fb3d"><td class="memItemLeft" align="right" valign="top"><a id="a05df36bbb7206ca0cfb8b5a74fb1fb3d"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a05df36bbb7206ca0cfb8b5a74fb1fb3d">numRanges</a> (void) const</td></tr>
<tr class="memdesc:a05df36bbb7206ca0cfb8b5a74fb1fb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> objects in container. <br /></td></tr>
<tr class="separator:a05df36bbb7206ca0cfb8b5a74fb1fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab11ea47a228e2689d18061df238dc6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRange.html">Range</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#aab11ea47a228e2689d18061df238dc6f">getFirstRange</a> (void) const</td></tr>
<tr class="memdesc:aab11ea47a228e2689d18061df238dc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a>.  <a href="#aab11ea47a228e2689d18061df238dc6f">More...</a><br /></td></tr>
<tr class="separator:aab11ea47a228e2689d18061df238dc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335abcacfeb584ef9684d60adfce11b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRange.html">Range</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a335abcacfeb584ef9684d60adfce11b9">getLastRange</a> (void) const</td></tr>
<tr class="memdesc:a335abcacfeb584ef9684d60adfce11b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a>.  <a href="#a335abcacfeb584ef9684d60adfce11b9">More...</a><br /></td></tr>
<tr class="separator:a335abcacfeb584ef9684d60adfce11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a80345a7c9f95568c00f6f1dbe2673"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRange.html">Range</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#af9a80345a7c9f95568c00f6f1dbe2673">getLastSignedRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spaceid) const</td></tr>
<tr class="memdesc:af9a80345a7c9f95568c00f6f1dbe2673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> viewing offsets as signed.  <a href="#af9a80345a7c9f95568c00f6f1dbe2673">More...</a><br /></td></tr>
<tr class="separator:af9a80345a7c9f95568c00f6f1dbe2673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa085a8e737c45ede0bf239e964901802"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRange.html">Range</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#aa085a8e737c45ede0bf239e964901802">getRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spaceid, uintb offset) const</td></tr>
<tr class="memdesc:aa085a8e737c45ede0bf239e964901802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> containing the given byte.  <a href="#aa085a8e737c45ede0bf239e964901802">More...</a><br /></td></tr>
<tr class="separator:aa085a8e737c45ede0bf239e964901802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ab4e29f9f3b6b096e985d99daac763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">insertRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:ab0ab4e29f9f3b6b096e985d99daac763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range of addresses.  <a href="#ab0ab4e29f9f3b6b096e985d99daac763">More...</a><br /></td></tr>
<tr class="separator:ab0ab4e29f9f3b6b096e985d99daac763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b0feea38aa56d2502426d117dccb31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a25b0feea38aa56d2502426d117dccb31">removeRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:a25b0feea38aa56d2502426d117dccb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a range of addresses.  <a href="#a25b0feea38aa56d2502426d117dccb31">More...</a><br /></td></tr>
<tr class="separator:a25b0feea38aa56d2502426d117dccb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdacecedb9b17b6a1b67f3f3d1d192e2"><td class="memItemLeft" align="right" valign="top"><a id="abdacecedb9b17b6a1b67f3f3d1d192e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#abdacecedb9b17b6a1b67f3f3d1d192e2">merge</a> (const <a class="el" href="classRangeList.html">RangeList</a> &amp;op2)</td></tr>
<tr class="memdesc:abdacecedb9b17b6a1b67f3f3d1d192e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge another <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> into <b>this</b>. <br /></td></tr>
<tr class="separator:abdacecedb9b17b6a1b67f3f3d1d192e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b4034c6930b45dd8d365c382c73b86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a61b4034c6930b45dd8d365c382c73b86">inRange</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a61b4034c6930b45dd8d365c382c73b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check containment an address range.  <a href="#a61b4034c6930b45dd8d365c382c73b86">More...</a><br /></td></tr>
<tr class="separator:a61b4034c6930b45dd8d365c382c73b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e1b36438b8366c0750f69080193271"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a01e1b36438b8366c0750f69080193271">longestFit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, uintb maxsize) const</td></tr>
<tr class="memdesc:a01e1b36438b8366c0750f69080193271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find size of biggest <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> containing given address.  <a href="#a01e1b36438b8366c0750f69080193271">More...</a><br /></td></tr>
<tr class="separator:a01e1b36438b8366c0750f69080193271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ed76aecdefbd58a4173fafb082a26c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#ae9ed76aecdefbd58a4173fafb082a26c">printBounds</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:ae9ed76aecdefbd58a4173fafb082a26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> to stream.  <a href="#ae9ed76aecdefbd58a4173fafb082a26c">More...</a><br /></td></tr>
<tr class="separator:ae9ed76aecdefbd58a4173fafb082a26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026dc31507600a1c8786b1d201f7a19e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a026dc31507600a1c8786b1d201f7a19e">saveXml</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a026dc31507600a1c8786b1d201f7a19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> to an XML stream.  <a href="#a026dc31507600a1c8786b1d201f7a19e">More...</a><br /></td></tr>
<tr class="separator:a026dc31507600a1c8786b1d201f7a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7c7b47cec0a38e75169896e08899d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#a7a7c7b47cec0a38e75169896e08899d0">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el, const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *manage)</td></tr>
<tr class="memdesc:a7a7c7b47cec0a38e75169896e08899d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> from an XML stream.  <a href="#a7a7c7b47cec0a38e75169896e08899d0">More...</a><br /></td></tr>
<tr class="separator:a7a7c7b47cec0a38e75169896e08899d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeea8688d0efb34c24e25f556e2e08f4e"><td class="memItemLeft" align="right" valign="top"><a id="aeea8688d0efb34c24e25f556e2e08f4e"></a>
set&lt; <a class="el" href="classRange.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeList.html#aeea8688d0efb34c24e25f556e2e08f4e">tree</a></td></tr>
<tr class="memdesc:aeea8688d0efb34c24e25f556e2e08f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sorted list of <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> objects. <br /></td></tr>
<tr class="separator:aeea8688d0efb34c24e25f556e2e08f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A disjoint set of Ranges, possibly across multiple address spaces. </p>
<p>This is a container for addresses. It maintains a disjoint list of Ranges that cover all the addresses in the container. Ranges can be inserted and removed, but overlapping/adjacent ranges will get merged. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aab11ea47a228e2689d18061df238dc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab11ea47a228e2689d18061df238dc6f">&#9670;&nbsp;</a></span>getFirstRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html">Range</a> * RangeList::getFirstRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the first contiguous range of addresses or NULL if empty </dd></dl>

</div>
</div>
<a id="a335abcacfeb584ef9684d60adfce11b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335abcacfeb584ef9684d60adfce11b9">&#9670;&nbsp;</a></span>getLastRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html">Range</a> * RangeList::getLastRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the last contiguous range of addresses or NULL if empty </dd></dl>

</div>
</div>
<a id="af9a80345a7c9f95568c00f6f1dbe2673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a80345a7c9f95568c00f6f1dbe2673">&#9670;&nbsp;</a></span>getLastSignedRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html">Range</a> * RangeList::getLastSignedRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spaceid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> viewing offsets as signed. </p>
<p>Treating offsets with their high-bits set as coming <em>before</em> offset where the high-bit is clear, return the last/latest contiguous <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> within the given address space </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceid</td><td>is the given address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indicated <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> or NULL if empty </dd></dl>

<p class="reference">References <a class="el" href="classAddrSpace.html#ab4c316eafd39b4e6c7a8017e01d5a841">AddrSpace::getHighest()</a>.</p>

</div>
</div>
<a id="aa085a8e737c45ede0bf239e964901802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa085a8e737c45ede0bf239e964901802">&#9670;&nbsp;</a></span>getRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html">Range</a> * RangeList::getRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spaceid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> containing the given byte. </p>
<p>If <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> contains the specific address (spaceid,offset), return it </p><dl class="section return"><dt>Returns</dt><dd>the containing <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> or NULL </dd></dl>

</div>
</div>
<a id="a61b4034c6930b45dd8d365c382c73b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b4034c6930b45dd8d365c382c73b86">&#9670;&nbsp;</a></span>inRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RangeList::inRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check containment an address range. </p>
<p>Make sure indicated range of addresses is <em>contained</em> in <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the first <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> in the target range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the target range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> is the range is fully contained by this <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> </dd></dl>

<p class="reference">References <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, and <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>.</p>

</div>
</div>
<a id="ab0ab4e29f9f3b6b096e985d99daac763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ab4e29f9f3b6b096e985d99daac763">&#9670;&nbsp;</a></span>insertRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RangeList::insertRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a range of addresses. </p>
<p>Insert a new <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> merging as appropriate to maintain the disjoint cover </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space containing the new range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the new range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the new range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01e1b36438b8366c0750f69080193271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e1b36438b8366c0750f69080193271">&#9670;&nbsp;</a></span>longestFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintb RangeList::longestFit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find size of biggest <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> containing given address. </p>
<p>Return the size of the biggest contiguous sequence of addresses in <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> which contain the given address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">maxsize</td><td>is the large range to consider before giving up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the biggest range </dd></dl>

<p class="reference">References <a class="el" href="classAddress.html#a208ce07ecf27e5c148d8395913831c2a">Address::getOffset()</a>, <a class="el" href="classAddress.html#a2e1cbf153126eebf5ba92f52c5dbc6a8">Address::getSpace()</a>, and <a class="el" href="classAddress.html#a90ea7ea47a048afa95a14709e704d876">Address::isInvalid()</a>.</p>

</div>
</div>
<a id="ae9ed76aecdefbd58a4173fafb082a26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ed76aecdefbd58a4173fafb082a26c">&#9670;&nbsp;</a></span>printBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RangeList::printBounds </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a description of <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> to stream. </p>
<p>Print a one line description of each disjoint <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> making up <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classRange.html#af79209e97d5e8df1e26846b478722909">Range::operator&lt;()</a>.</p>

</div>
</div>
<a id="a25b0feea38aa56d2502426d117dccb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b0feea38aa56d2502426d117dccb31">&#9670;&nbsp;</a></span>removeRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RangeList::removeRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a range of addresses. </p>
<p>Remove/narrow/split existing <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> objects to eliminate the indicated addresses while still maintaining a disjoint cover. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the address range to remove </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte of the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a7c7b47cec0a38e75169896e08899d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7c7b47cec0a38e75169896e08899d0">&#9670;&nbsp;</a></span>restoreXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RangeList::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td>
          <td class="paramname"><em>manage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> from an XML stream. </p>
<p>Recover each individual disjoint <a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> for <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> as encoded in a &lt;rangelist&gt; tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
    <tr><td class="paramname">manage</td><td>is manager for retrieving address spaces </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classRange.html#ad88a42471281f5bc6abf1dc1fb79f12b">Range::restoreXml()</a>, and <a class="el" href="address_8hh.html#af65db839ac7c389dab6cba2187c2e867">uintbmasks</a>.</p>

</div>
</div>
<a id="a026dc31507600a1c8786b1d201f7a19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026dc31507600a1c8786b1d201f7a19e">&#9670;&nbsp;</a></span>saveXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RangeList::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write <b>this</b> <a class="el" href="classRangeList.html" title="A disjoint set of Ranges, possibly across multiple address spaces. ">RangeList</a> to an XML stream. </p>
<p>Serialize this object to an XML &lt;rangelist&gt; tag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="address_8hh.html">address.hh</a></li>
<li>address.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
