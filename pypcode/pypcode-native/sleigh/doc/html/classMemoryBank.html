<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: MemoryBank Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMemoryBank-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MemoryBank Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory storage/state for a single AddressSpace.  
 <a href="classMemoryBank.html#details">More...</a></p>

<p><code>#include &lt;memstate.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MemoryBank:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMemoryBank.png" usemap="#MemoryBank_map" alt=""/>
  <map id="MemoryBank_map" name="MemoryBank_map">
<area href="classMemoryHashOverlay.html" title="A memory bank that implements reads and writes using a hash table. " alt="MemoryHashOverlay" shape="rect" coords="0,56,133,80"/>
<area href="classMemoryImage.html" title="A kind of MemoryBank which retrieves its data from an underlying LoadImage. " alt="MemoryImage" shape="rect" coords="143,56,276,80"/>
<area href="classMemoryPageOverlay.html" title="Memory bank that overlays some other memory bank, using a &quot;copy on write&quot; behavior. " alt="MemoryPageOverlay" shape="rect" coords="286,56,419,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a87f6e0315637453fa0e1bd5110b9bdc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a87f6e0315637453fa0e1bd5110b9bdc9">MemoryBank</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 ws, int4 ps)</td></tr>
<tr class="memdesc:a87f6e0315637453fa0e1bd5110b9bdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic constructor for a memory bank.  <a href="#a87f6e0315637453fa0e1bd5110b9bdc9">More...</a><br /></td></tr>
<tr class="separator:a87f6e0315637453fa0e1bd5110b9bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996d7c04af8f8bf02ce7abb91d693dc5"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a996d7c04af8f8bf02ce7abb91d693dc5">getWordSize</a> (void) const</td></tr>
<tr class="memdesc:a996d7c04af8f8bf02ce7abb91d693dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in a word for this memory bank.  <a href="#a996d7c04af8f8bf02ce7abb91d693dc5">More...</a><br /></td></tr>
<tr class="separator:a996d7c04af8f8bf02ce7abb91d693dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020cac2b86f83b069c2f1914bc70cb2b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a020cac2b86f83b069c2f1914bc70cb2b">getPageSize</a> (void) const</td></tr>
<tr class="memdesc:a020cac2b86f83b069c2f1914bc70cb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in a page for this memory bank.  <a href="#a020cac2b86f83b069c2f1914bc70cb2b">More...</a><br /></td></tr>
<tr class="separator:a020cac2b86f83b069c2f1914bc70cb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8f3ea79a07142e2d655eccf4ebc0f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a8e8f3ea79a07142e2d655eccf4ebc0f0">getSpace</a> (void) const</td></tr>
<tr class="memdesc:a8e8f3ea79a07142e2d655eccf4ebc0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address space associated with this memory bank.  <a href="#a8e8f3ea79a07142e2d655eccf4ebc0f0">More...</a><br /></td></tr>
<tr class="separator:a8e8f3ea79a07142e2d655eccf4ebc0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331f70cbc9d2c7172ebbaaa7e185c1e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a331f70cbc9d2c7172ebbaaa7e185c1e9">setValue</a> (uintb offset, int4 size, uintb val)</td></tr>
<tr class="memdesc:a331f70cbc9d2c7172ebbaaa7e185c1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a (small) range of bytes.  <a href="#a331f70cbc9d2c7172ebbaaa7e185c1e9">More...</a><br /></td></tr>
<tr class="separator:a331f70cbc9d2c7172ebbaaa7e185c1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8149ad04fb877f78b56abd1b67962b31"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a8149ad04fb877f78b56abd1b67962b31">getValue</a> (uintb offset, int4 size) const</td></tr>
<tr class="memdesc:a8149ad04fb877f78b56abd1b67962b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value encoded in a (small) range of bytes.  <a href="#a8149ad04fb877f78b56abd1b67962b31">More...</a><br /></td></tr>
<tr class="separator:a8149ad04fb877f78b56abd1b67962b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ed4c66d1ea57306e6bd9ed1a5de787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a99ed4c66d1ea57306e6bd9ed1a5de787">setChunk</a> (uintb offset, int4 size, const uint1 *val)</td></tr>
<tr class="memdesc:a99ed4c66d1ea57306e6bd9ed1a5de787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values of an arbitrary sequence of bytes.  <a href="#a99ed4c66d1ea57306e6bd9ed1a5de787">More...</a><br /></td></tr>
<tr class="separator:a99ed4c66d1ea57306e6bd9ed1a5de787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a81a70ff478940fac0399a2cfbe86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#af45a81a70ff478940fac0399a2cfbe86">getChunk</a> (uintb offset, int4 size, uint1 *res) const</td></tr>
<tr class="memdesc:af45a81a70ff478940fac0399a2cfbe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an arbitrary sequence of bytes.  <a href="#af45a81a70ff478940fac0399a2cfbe86">More...</a><br /></td></tr>
<tr class="separator:af45a81a70ff478940fac0399a2cfbe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeba21f6794e4fa90b9acf48f4bef7278"><td class="memItemLeft" align="right" valign="top">static uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#aeba21f6794e4fa90b9acf48f4bef7278">constructValue</a> (const uint1 *ptr, int4 size, bool bigendian)</td></tr>
<tr class="memdesc:aeba21f6794e4fa90b9acf48f4bef7278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode bytes to value.  <a href="#aeba21f6794e4fa90b9acf48f4bef7278">More...</a><br /></td></tr>
<tr class="separator:aeba21f6794e4fa90b9acf48f4bef7278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cc660245fbe563982d49d68b6d2e02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#ab0cc660245fbe563982d49d68b6d2e02">deconstructValue</a> (uint1 *ptr, uintb val, int4 size, bool bigendian)</td></tr>
<tr class="memdesc:ab0cc660245fbe563982d49d68b6d2e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode value to bytes.  <a href="#ab0cc660245fbe563982d49d68b6d2e02">More...</a><br /></td></tr>
<tr class="separator:ab0cc660245fbe563982d49d68b6d2e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abccbb8ba1e2c2ae941b372e90f454e5f"><td class="memItemLeft" align="right" valign="top"><a id="abccbb8ba1e2c2ae941b372e90f454e5f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#abccbb8ba1e2c2ae941b372e90f454e5f">insert</a> (uintb addr, uintb val)=0</td></tr>
<tr class="memdesc:abccbb8ba1e2c2ae941b372e90f454e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a word in memory bank at an aligned location. <br /></td></tr>
<tr class="separator:abccbb8ba1e2c2ae941b372e90f454e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a5b8dd872d0c3e462d9055fa4266d"><td class="memItemLeft" align="right" valign="top"><a id="a421a5b8dd872d0c3e462d9055fa4266d"></a>
virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a421a5b8dd872d0c3e462d9055fa4266d">find</a> (uintb addr) const =0</td></tr>
<tr class="memdesc:a421a5b8dd872d0c3e462d9055fa4266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a word from memory bank at an aligned location. <br /></td></tr>
<tr class="separator:a421a5b8dd872d0c3e462d9055fa4266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48e5c77befa62116190b34611ad4339"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#ac48e5c77befa62116190b34611ad4339">getPage</a> (uintb addr, uint1 *res, int4 skip, int4 size) const</td></tr>
<tr class="memdesc:ac48e5c77befa62116190b34611ad4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve data from a memory <em>page</em>.  <a href="#ac48e5c77befa62116190b34611ad4339">More...</a><br /></td></tr>
<tr class="separator:ac48e5c77befa62116190b34611ad4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf2318442e1f7da99ae85f63f9df19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a68bf2318442e1f7da99ae85f63f9df19">setPage</a> (uintb addr, const uint1 *val, int4 skip, int4 size)</td></tr>
<tr class="memdesc:a68bf2318442e1f7da99ae85f63f9df19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into a memory page.  <a href="#a68bf2318442e1f7da99ae85f63f9df19">More...</a><br /></td></tr>
<tr class="separator:a68bf2318442e1f7da99ae85f63f9df19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7887f20432d244d77e14e91dd3eaa02a"><td class="memItemLeft" align="right" valign="top"><a id="a7887f20432d244d77e14e91dd3eaa02a"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a></td></tr>
<tr class="memdesc:a7887f20432d244d77e14e91dd3eaa02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes in an aligned word access. <br /></td></tr>
<tr class="separator:a7887f20432d244d77e14e91dd3eaa02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec6d734637ed07a04050330f8eea2aa"><td class="memItemLeft" align="right" valign="top"><a id="a4ec6d734637ed07a04050330f8eea2aa"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a4ec6d734637ed07a04050330f8eea2aa">pagesize</a></td></tr>
<tr class="memdesc:a4ec6d734637ed07a04050330f8eea2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes in an aligned page access. <br /></td></tr>
<tr class="separator:a4ec6d734637ed07a04050330f8eea2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcf6faec218d7839ca55ad13402c5a1"><td class="memItemLeft" align="right" valign="top"><a id="a5bcf6faec218d7839ca55ad13402c5a1"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a></td></tr>
<tr class="memdesc:a5bcf6faec218d7839ca55ad13402c5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address space associated with this memory. <br /></td></tr>
<tr class="separator:a5bcf6faec218d7839ca55ad13402c5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abfa1478e94e6c9f59f450ea1a3394466"><td class="memItemLeft" align="right" valign="top"><a id="abfa1478e94e6c9f59f450ea1a3394466"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryPageOverlay</b></td></tr>
<tr class="separator:abfa1478e94e6c9f59f450ea1a3394466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef831bed4bde79676024649093dec95"><td class="memItemLeft" align="right" valign="top"><a id="aaef831bed4bde79676024649093dec95"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryHashOverlay</b></td></tr>
<tr class="separator:aaef831bed4bde79676024649093dec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory storage/state for a single AddressSpace. </p>
<p>Class for setting and getting memory values within a space The basic API is to get/set arrays of byte values via offset within the space. Helper functions getValue and setValue easily retrieve/store integers of various sizes from memory, using the endianness encoding specified by the space. Accesses through the public interface, are automatically broken down into <b>word</b> accesses, through the private insert/find methods, and <b>page</b> accesses through getPage/setPage. So these are the virtual methods that need to be overridden in the derived classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a87f6e0315637453fa0e1bd5110b9bdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f6e0315637453fa0e1bd5110b9bdc9">&#9670;&nbsp;</a></span>MemoryBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBank::MemoryBank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic constructor for a memory bank. </p>
<p>A <a class="el" href="classMemoryBank.html" title="Memory storage/state for a single AddressSpace. ">MemoryBank</a> must be associated with a specific address space, have a preferred or natural <em>wordsize</em> and a natural <em>pagesize</em>. Both the <em>wordsize</em> and <em>pagesize</em> must be a power of 2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the associated address space </td></tr>
    <tr><td class="paramname">ws</td><td>is the number of bytes in the preferred wordsize </td></tr>
    <tr><td class="paramname">ps</td><td>is the number of bytes in a page </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classMemoryBank.html#a4ec6d734637ed07a04050330f8eea2aa">pagesize</a>, <a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a>, and <a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeba21f6794e4fa90b9acf48f4bef7278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba21f6794e4fa90b9acf48f4bef7278">&#9670;&nbsp;</a></span>constructValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb MemoryBank::constructValue </td>
          <td>(</td>
          <td class="paramtype">const uint1 *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bigendian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode bytes to value. </p>
<p>This is a static convenience routine for decoding a value from a sequence of bytes depending on the desired endianness </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>is the pointer to the bytes to decode </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes </td></tr>
    <tr><td class="paramname">bigendian</td><td>is <b>true</b> if the bytes are encoded in big endian form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decoded value </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMemoryPageOverlay.html#a7ba248277eadf04ca7895dea1e614148">MemoryPageOverlay::find()</a>.</p>

</div>
</div>
<a id="ab0cc660245fbe563982d49d68b6d2e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cc660245fbe563982d49d68b6d2e02">&#9670;&nbsp;</a></span>deconstructValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBank::deconstructValue </td>
          <td>(</td>
          <td class="paramtype">uint1 *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bigendian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode value to bytes. </p>
<p>This is a static convenience routine for encoding bytes from a given value, depending on the desired endianness </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>is a pointer to the location to write the encoded bytes </td></tr>
    <tr><td class="paramname">val</td><td>is the value to be encoded </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes to encode </td></tr>
    <tr><td class="paramname">bigendian</td><td>is <b>true</b> if a big endian encoding is desired </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classMemoryPageOverlay.html#a4dad83693ae5fe82459e9bdcb3f2415f">MemoryPageOverlay::insert()</a>.</p>

</div>
</div>
<a id="af45a81a70ff478940fac0399a2cfbe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45a81a70ff478940fac0399a2cfbe86">&#9670;&nbsp;</a></span>getChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBank::getChunk </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint1 *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an arbitrary sequence of bytes. </p>
<p>This is the most general method for reading a sequence of bytes from the memory bank. There is no restriction on the offset or the number of bytes to read, except that the range must be contained in the address space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the start of the byte range to read </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes to read </td></tr>
    <tr><td class="paramname">res</td><td>is a pointer to where the retrieved bytes should be stored </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classMemoryBank.html#ac48e5c77befa62116190b34611ad4339">getPage()</a>, and <a class="el" href="classMemoryBank.html#a4ec6d734637ed07a04050330f8eea2aa">pagesize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryState.html#ab8ea70436398ce942b25366b71b26506">MemoryState::getChunk()</a>.</p>

</div>
</div>
<a id="ac48e5c77befa62116190b34611ad4339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48e5c77befa62116190b34611ad4339">&#9670;&nbsp;</a></span>getPage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBank::getPage </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint1 *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve data from a memory <em>page</em>. </p>
<p>This routine only retrieves data from a single <em>page</em> in the memory bank. Bytes need not be retrieved from the exact start of a page, but all bytes must come from <em>one</em> page. A page is a fixed number of bytes, and the address of a page is always aligned based on that number of bytes. This routine may be overridden for a page based implementation of the <a class="el" href="classMemoryBank.html" title="Memory storage/state for a single AddressSpace. ">MemoryBank</a>. The default implementation retrieves the page as aligned words using the find method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the <em>aligned</em> offset of the desired page </td></tr>
    <tr><td class="paramname">res</td><td>is a pointer to where fetched data should be written </td></tr>
    <tr><td class="paramname">skip</td><td>is the offset <em>into</em> <em>the</em> <em>page</em> to get the bytes from </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes to retrieve </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMemoryPageOverlay.html#a0b502920d00bee935fdd15a2e2d823f2">MemoryPageOverlay</a>, and <a class="el" href="classMemoryImage.html#abcf3229adb6b824702b627d1de5a9f10">MemoryImage</a>.</p>

<p class="reference">References <a class="el" href="address_8hh.html#aedcacdf1dd5af3b58d59d76b8011d0f1">byte_swap()</a>, <a class="el" href="classMemoryBank.html#a421a5b8dd872d0c3e462d9055fa4266d">find()</a>, <a class="el" href="classAddrSpace.html#af5683c0d7e42edec80b97bcb9fb3dc11">AddrSpace::isBigEndian()</a>, <a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a>, and <a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryBank.html#af45a81a70ff478940fac0399a2cfbe86">getChunk()</a>, and <a class="el" href="classMemoryImage.html#a8bf36a4938f306fedbd4d409406cc102">MemoryImage::insert()</a>.</p>

</div>
</div>
<a id="a020cac2b86f83b069c2f1914bc70cb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020cac2b86f83b069c2f1914bc70cb2b">&#9670;&nbsp;</a></span>getPageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 MemoryBank::getPageSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes in a page for this memory bank. </p>
<p>A <a class="el" href="classMemoryBank.html" title="Memory storage/state for a single AddressSpace. ">MemoryBank</a> is instantiated with a <em>natural</em> page size. Requests for large chunks of data may be broken down into units of this size. </p><dl class="section return"><dt>Returns</dt><dd>the number of bytes in a <em>page</em>. </dd></dl>

<p class="reference">References <a class="el" href="classMemoryBank.html#a4ec6d734637ed07a04050330f8eea2aa">pagesize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryPageOverlay.html#a7ba248277eadf04ca7895dea1e614148">MemoryPageOverlay::find()</a>, <a class="el" href="classMemoryPageOverlay.html#a4dad83693ae5fe82459e9bdcb3f2415f">MemoryPageOverlay::insert()</a>, and <a class="el" href="classMemoryPageOverlay.html#a1d713334ec06e47cfdfcf76f0649eb71">MemoryPageOverlay::setPage()</a>.</p>

</div>
</div>
<a id="a8e8f3ea79a07142e2d655eccf4ebc0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8f3ea79a07142e2d655eccf4ebc0f0">&#9670;&nbsp;</a></span>getSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * MemoryBank::getSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address space associated with this memory bank. </p>
<p>A <a class="el" href="classMemoryBank.html" title="Memory storage/state for a single AddressSpace. ">MemoryBank</a> is a contiguous sequence of bytes associated with a particular address space. </p><dl class="section return"><dt>Returns</dt><dd>the AddressSpace associated with this bank. </dd></dl>

<p class="reference">References <a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryImage.html#a196464ef9a11a0088aa62d01e510aabf">MemoryImage::find()</a>, <a class="el" href="classMemoryPageOverlay.html#a7ba248277eadf04ca7895dea1e614148">MemoryPageOverlay::find()</a>, <a class="el" href="classMemoryImage.html#abcf3229adb6b824702b627d1de5a9f10">MemoryImage::getPage()</a>, <a class="el" href="classMemoryPageOverlay.html#a4dad83693ae5fe82459e9bdcb3f2415f">MemoryPageOverlay::insert()</a>, and <a class="el" href="classMemoryState.html#ad1c31dbc7de2dfb6926537c7f9166e92">MemoryState::setMemoryBank()</a>.</p>

</div>
</div>
<a id="a8149ad04fb877f78b56abd1b67962b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8149ad04fb877f78b56abd1b67962b31">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintb MemoryBank::getValue </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value encoded in a (small) range of bytes. </p>
<p>This routine gets the value from a range of bytes at an arbitrary address. It takes into account the endianness of the underlying space when decoding the value. The value is constructed by making one or more aligned word queries, using the find method. The desired value may span multiple words and is reconstructed properly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the start of the byte range encoding the value </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decoded value </dd></dl>

<p class="reference">References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classMemoryBank.html#a421a5b8dd872d0c3e462d9055fa4266d">find()</a>, <a class="el" href="classAddrSpace.html#af5683c0d7e42edec80b97bcb9fb3dc11">AddrSpace::isBigEndian()</a>, <a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a>, and <a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryState.html#ae4d10a6ac34ebd96017915c5b6a39375">MemoryState::getValue()</a>.</p>

</div>
</div>
<a id="a996d7c04af8f8bf02ce7abb91d693dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996d7c04af8f8bf02ce7abb91d693dc5">&#9670;&nbsp;</a></span>getWordSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 MemoryBank::getWordSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes in a word for this memory bank. </p>
<p>A <a class="el" href="classMemoryBank.html" title="Memory storage/state for a single AddressSpace. ">MemoryBank</a> is instantiated with a <em>natural</em> word size. Requests for arbitrary byte ranges may be broken down into units of this size. </p><dl class="section return"><dt>Returns</dt><dd>the number of bytes in a <em>word</em>. </dd></dl>

<p class="reference">References <a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryImage.html#a196464ef9a11a0088aa62d01e510aabf">MemoryImage::find()</a>, <a class="el" href="classMemoryPageOverlay.html#a7ba248277eadf04ca7895dea1e614148">MemoryPageOverlay::find()</a>, and <a class="el" href="classMemoryPageOverlay.html#a4dad83693ae5fe82459e9bdcb3f2415f">MemoryPageOverlay::insert()</a>.</p>

</div>
</div>
<a id="a99ed4c66d1ea57306e6bd9ed1a5de787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ed4c66d1ea57306e6bd9ed1a5de787">&#9670;&nbsp;</a></span>setChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBank::setChunk </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint1 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set values of an arbitrary sequence of bytes. </p>
<p>This the most general method for writing a sequence of bytes into the memory bank. There is no restriction on the offset to write to or the number of bytes to be written, except that the range must be contained in the address space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the start of the byte range to be written </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes to write </td></tr>
    <tr><td class="paramname">val</td><td>is a pointer to the sequence of bytes to be written into the bank </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classMemoryBank.html#a4ec6d734637ed07a04050330f8eea2aa">pagesize</a>, and <a class="el" href="classMemoryBank.html#a68bf2318442e1f7da99ae85f63f9df19">setPage()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryState.html#aa8d03c2a848a00090098b75f1fe877e1">MemoryState::setChunk()</a>.</p>

</div>
</div>
<a id="a68bf2318442e1f7da99ae85f63f9df19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf2318442e1f7da99ae85f63f9df19">&#9670;&nbsp;</a></span>setPage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBank::setPage </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint1 *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into a memory page. </p>
<p>This routine writes data only to a single <em>page</em> of the memory bank. Bytes need not be written to the exact start of the page, but all bytes must be written to only one page when using this routine. A page is a fixed number of bytes, and the address of a page is always aligned based on this size. This routine may be overridden for a page based implementation of the <a class="el" href="classMemoryBank.html" title="Memory storage/state for a single AddressSpace. ">MemoryBank</a>. The default implementation writes the page as a sequence of aligned words, using the insert method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the <em>aligned</em> offset of the desired page </td></tr>
    <tr><td class="paramname">val</td><td>is a pointer to the bytes to be written into the page </td></tr>
    <tr><td class="paramname">skip</td><td>is the offset <em>into</em> <em>the</em> <em>page</em> where bytes will be written </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes to be written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMemoryPageOverlay.html#a1d713334ec06e47cfdfcf76f0649eb71">MemoryPageOverlay</a>.</p>

<p class="reference">References <a class="el" href="address_8hh.html#aedcacdf1dd5af3b58d59d76b8011d0f1">byte_swap()</a>, <a class="el" href="classMemoryBank.html#a421a5b8dd872d0c3e462d9055fa4266d">find()</a>, <a class="el" href="classMemoryBank.html#abccbb8ba1e2c2ae941b372e90f454e5f">insert()</a>, <a class="el" href="classAddrSpace.html#af5683c0d7e42edec80b97bcb9fb3dc11">AddrSpace::isBigEndian()</a>, <a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a>, and <a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryBank.html#a99ed4c66d1ea57306e6bd9ed1a5de787">setChunk()</a>.</p>

</div>
</div>
<a id="a331f70cbc9d2c7172ebbaaa7e185c1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f70cbc9d2c7172ebbaaa7e185c1e9">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBank::setValue </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a (small) range of bytes. </p>
<p>This routine is used to set a single value in the memory bank at an arbitrary address It takes into account the endianness of the associated address space when encoding the value as bytes in the bank. The value is broken up into aligned pieces of <em>wordsize</em> and the actual <b>write</b> is performed with the insert routine. If only parts of aligned words are written to, then the remaining parts are filled in with the original value, via the find routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the start of the byte range to write </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range to write </td></tr>
    <tr><td class="paramname">val</td><td>is the value to be written </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classMemoryBank.html#a421a5b8dd872d0c3e462d9055fa4266d">find()</a>, <a class="el" href="classMemoryBank.html#abccbb8ba1e2c2ae941b372e90f454e5f">insert()</a>, <a class="el" href="classAddrSpace.html#af5683c0d7e42edec80b97bcb9fb3dc11">AddrSpace::isBigEndian()</a>, <a class="el" href="classMemoryBank.html#a5bcf6faec218d7839ca55ad13402c5a1">space</a>, and <a class="el" href="classMemoryBank.html#a7887f20432d244d77e14e91dd3eaa02a">wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMemoryState.html#af4abdf013cacfaa4cfbe223f3893a76a">MemoryState::setValue()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="memstate_8hh.html">memstate.hh</a></li>
<li>memstate.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
